---
import GeneratorOutput from './GeneratorOutput.astro'

const placeholder = `<script src="https://cdn.usefathom.com/script.js" data-site="ABCDEFG" defer></script>`
---

<starlight-head-generator>
  <section>
    <form>
      <label for="input">Enter the tags to add to your Starlight <code>`&lt;head&gt;`</code>:</label>
      <textarea
        aria-autocomplete="none"
        aria-multiline="true"
        aria-required="true"
        autocomplete="off"
        id="input"
        name="input"
        {placeholder}
        required
        spellcheck="false"></textarea>
      <div class="controls">
        <input type="reset" />
        <button type="submit">Generate</button>
      </div>
    </form>
  </section>
  <section class="error hidden" id="error"></section>
  <section class="output hidden" id="output">
    <GeneratorOutput />
  </section>
</starlight-head-generator>

<style>
  section {
    background-color: var(--color-slate-800);
    border: 2px solid var(--color-slate-600);
    border-radius: var(--rounded-md);
    padding: var(--size-4);
  }

  section.error {
    background-color: var(--color-red-500);
    border: 2px solid var(--color-red-300);
  }

  section.output {
    padding: 0;
  }

  section + section {
    margin-top: var(--size-4);
  }

  @media (min-width: 640px) {
    section + section {
      margin-top: var(--size-8);
    }
  }

  form {
    display: flex;
    flex-direction: column;
  }

  label {
    font-weight: var(--font-semibold);
    line-height: 1.4;
    margin-bottom: var(--size-4);
  }

  code {
    font-size: var(--text-sm);
    line-height: 1.2;
  }

  textarea {
    background-color: var(--color-slate-700);
    border: 2px solid var(--color-slate-500);
    border-radius: var(--rounded);
    font-family: var(--font-mono);
    font-size: var(--text-sm);
    height: var(--size-24);
    line-height: 1.5;
    margin-bottom: var(--size-4);
    padding: var(--size-1) var(--size-2);
    resize: none;
  }

  textarea:focus-visible {
    outline: 2px solid var(--color-slate-200);
    outline-offset: 2px;
  }

  textarea::placeholder {
    color: var(--color-slate-500);
  }

  .controls {
    display: flex;
    flex-direction: column;
    gap: var(--size-3);
  }

  button,
  input[type='reset'] {
    background-color: var(--color-slate-900);
    border: 2px solid var(--color-slate-700);
    border-radius: var(--rounded);
    cursor: pointer;
    flex-basis: 50%;
    font-size: var(--text-lg);
    font-weight: var(--font-semibold);
    padding: var(--size-1) var(--size-4);
  }

  :is(button, input[type='reset']):hover {
    background-color: var(--color-slate-950);
  }

  :is(button, input[type='reset']):focus-visible {
    background-color: var(--color-slate-950);
    outline: 2px solid var(--color-slate-200);
    outline-offset: 2px;
  }

  :is(button:hover, input[type='reset']):active {
    background-color: var(--color-slate-800);
  }

  @media (min-width: 480px) {
    .controls {
      flex-direction: row;
    }
  }

  .hidden {
    display: none;
  }
</style>

<script>
  customElements.define(
    'starlight-head-generator',
    class StarlightHeadGenerator extends HTMLElement {
      #form: HTMLFormElement | null
      #error: HTMLElement | null
      #output: HTMLElement | null

      constructor() {
        super()

        this.#form = this.querySelector('form')
        this.#error = this.querySelector('#error')
        this.#output = this.querySelector('#output')

        this.#form?.addEventListener('submit', this.#handleSubmit)
        this.#form?.addEventListener('reset', this.#handleReset)
        this.querySelector('textarea')?.addEventListener('keydown', this.#handleInputKeyDown)
      }

      #handleSubmit = (event: SubmitEvent) => {
        this.#resetUI()

        if (!(event.target instanceof HTMLFormElement)) return

        if (!event.target.checkValidity()) {
          event.target.reportValidity()
          return
        }

        event.preventDefault()

        const input = new FormData(event.target).get('input')
        if (typeof input !== 'string') return

        const parser = new DOMParser()
        const parsedHtml = parser.parseFromString(input, 'text/html')
        const head = parsedHtml.querySelector('head')

        if (!head || head.children.length === 0) {
          this.#showError('// TODO(HiDeoo) ')
          return
        }

        this.#showOutput(this.#getOutput(head.children))
      }

      #handleReset = () => {
        this.#resetUI()
      }

      #handleInputKeyDown = (event: KeyboardEvent) => {
        if (event.key !== 'Enter' || event.shiftKey) {
          return
        }

        event.preventDefault()

        this.#form?.dispatchEvent(new Event('submit', { cancelable: true }))
      }

      #resetUI = () => {
        this.#error?.classList.add('hidden')
        this.#output?.classList.add('hidden')
      }

      #showError = (msg: string) => {
        if (!this.#error) return

        this.#error.classList.remove('hidden')
        this.#error.textContent = msg
      }

      #showOutput = (output: Output) => {
        if (!this.#output) return

        const jsPanel = this.#output.querySelector('#format-panel-js')
        const yamlPanel = this.#output.querySelector('#format-panel-yaml')

        if (!jsPanel || !yamlPanel) return

        this.#output.classList.remove('hidden')
        jsPanel.textContent = output.js
        yamlPanel.textContent = output.yaml
      }

      #getOutput(tags: HTMLCollection): Output {
        const headConfigs = [...tags].map(this.#getHeadConfigFromElement)

        return {
          js: JSON.stringify(headConfigs, null, 2),
          yaml: '// TODO(HiDeoo) ',
        }
      }

      #getHeadConfigFromElement(element: Element): HeadConfig {
        const headConfig: HeadConfig = { tag: element.tagName.toLowerCase() }

        if (element.textContent && element.textContent.trim().length > 0) {
          headConfig.content = element.textContent
        }

        if (element.attributes.length > 0) {
          headConfig.attrs = {}

          for (const attr of element.attributes) {
            headConfig.attrs[attr.name] = attr.value
          }
        }

        return headConfig
      }
    },
  )

  interface HeadConfig {
    attrs?: Record<string, string | boolean | undefined>
    content?: string
    tag: string
  }

  interface Output {
    js: string
    yaml: string
  }
</script>
